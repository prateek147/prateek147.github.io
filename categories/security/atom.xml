<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: security | Prateek Gianchandani]]></title>
  <link href="http://prateek147.github.io//categories/security/atom.xml" rel="self"/>
  <link href="http://prateek147.github.io/"/>
  <updated>2015-05-17T14:19:05+04:00</updated>
  <id>http://prateek147.github.io/</id>
  <author>
    <name><![CDATA[Prateek Gianchandani]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS Application Security Part 43 - FAT binaries &amp; LLDB usage continued]]></title>
    <link href="http://prateek147.github.io/2015/05/17/ios-application-security-part-43-fat-binaries-and-lldb-usage-continued"/>
    <updated>2015-05-17T14:18:00+04:00</updated>
    <id>http://prateek147.github.io/2015/05/17/ios-application-security-part-43-fat-binaries-and-lldb-usage-continued</id>
    <content type="html"><![CDATA[<p>In this article, we will talk about FAT binaries and see more usage of LLDB.</p>




<p>Fat binaries are single binaries that are compiled for different architectures. They are done so because it is easier to ship a single binary for different architectures. Apple has been changing the architecture in the last three versions of it's iPhones, armv7, armv7s, and arm64. The good thing is that new iOS devices can run applications compiled for older architectures as well. However it is recommended to upgrade the architecture of the application for enhanced performance.</p>




<p>You can see the architecture for your project by going to the Project in Xcode and looking under Build Settings.</p>


<p><img src="http://prateek147.github.io/images/posts/ios43/1.png" width="645" height="229" alt="1"></p>

<!-- more -->




<p>A good way to find the architectures for which a binary is deployed is using otool. You can use the -f command to look at the fat headers.</p>


<p><img src="http://prateek147.github.io/images/posts/ios43/2.png" width="243" height="202" alt="2"></p>

<p>As you can see, it doesn't mention the architecture name but the cputype and cpusubtype. However, after a bit of lookup from the information on cputype and cpusubtype, you can find out that the first one is armv7s whereas the second one is armv64. You can also use Clutch to find this out. Whitle decrypting, it can give information about the kinds of architectures the binary had. As you can see, in this case it was armv7 and arm64.</p>


<p><img src="http://prateek147.github.io/images/posts/ios43/3.png" width="514" height="332" alt="3"></p>

<p>The easiest way is to find via the tool lipo</p>


<p><img src="http://prateek147.github.io/images/posts/ios43/3s.png" width="576" height="42" alt="3s"></p>

<p>In some cases, if some tool doesn't work against a particular application, it is better to strip that architecture from the binary. This can be done using a tool named lipo. This is essentially useful as a lot of tools don't work against arm64 binaries.</p>


<p><img src="http://prateek147.github.io/images/posts/ios43/4.png" width="743" height="137" alt="4"></p>

<p>So with this little intro about fat binaries out of the way, lets carry on using LLDB. Like last article, we will be performing the analysis on Twitter app. Using Hopper, we can see some methods in the Twitter app.</p>


<p></p>

<p><img src="http://prateek147.github.io/images/posts/ios43/5.png" width="1019" height="551" alt="5"></p>

<p>So let's set a breakpoint for the method <i>b -[T1CommerceOfferHowWorksView setHiddenObserver:]</i>.</p>


<p><img src="http://prateek147.github.io/images/posts/ios43/6.png" width="557" height="76" alt="6"></p>

<p>Oops, looks like we are unable to set a breakpoint. But why is that ? The reason is, LLDB hasn't loaded the symbols from the binary yet. The symbols are what contains information about the class names and methods. This is unlike GDB where it loads the symbols while performing analysis on the binary. Remember however that you are running the LLDB client on your system and not the device. To confirm that you have not yet loaded the symbols, you can use the command <i>image dump symtab</i> to load the symbols and look for this particular method, you will not find it.</p>


<p><img src="http://prateek147.github.io/images/posts/ios43/7.png" width="902" height="427" alt="7"></p>

<p>In order to load the symbols from the binary into LLDB, first download the LLDB binary onto your computer, then use the following command to load the symbols. Note that the architeture is set to armv7 by default.</p>


<p><img src="http://prateek147.github.io/images/posts/ios43/8.png" width="605" height="65" alt="8"></p>

<p>And now, you can see that you can set the breakpoint.</p>


<p><img src="http://prateek147.github.io/images/posts/ios43/9.png" width="854" height="59" alt="9"></p>

<p>If you know that the app is compiled for a 64 bit architecture, and the device is a 64 bit device, you should set the architecture to arm64. Does that make a difference ? Yes. Because the address will be different for the same method for different architectures (Fat binaries) and the method will not be called if you have set the breakpoint for a different architecture than the device it is compiled on.</p>


<p><img src="http://prateek147.github.io/images/posts/ios43/10.png" width="921" height="101" alt="10"></p>

<p>Another thing. If you ever run a command and get the error <i>invalid frame</i>, it means that the process is still running. In order to execute commands, the process must be paused. This can be done using the <i>process interrupt</i> command.</p>


<p><img src="http://prateek147.github.io/images/posts/ios43/x1.png" width="477" height="99" alt="X1">
<img src="http://prateek147.github.io/images/posts/ios43/x2.png" width="570" height="259" alt="X2"></p>

<p>If you think that arm64 is hard to understand and it is a bit difficult to modify the runtime flow, you can load the same executable on a 32 bit device and use GDB or LLDB to modify the variables and change the runtime flow. This is because most applications currently come with 32 bit support. However, in the coming year or so, this will not be the case. We will also cover arm64 assembly in a later article.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Application Security Part 42 - LLDB Usage continued]]></title>
    <link href="http://prateek147.github.io/2015/05/12/ios-application-security-part-42-lldb-usage-continued"/>
    <updated>2015-05-12T00:10:00+04:00</updated>
    <id>http://prateek147.github.io/2015/05/12/ios-application-security-part-42-lldb-usage-continued</id>
    <content type="html"><![CDATA[<p>In this article, we will look at some of the most important commands in LLDB to debug applications.</p>




<p>If you have been following this blog series, you would have noticed that we have been using GDB until now for debugging applications, but the support for GDB has been disabled by Apple. Apple has compiled a very useful list of GDB to LLDB commands to get you up to date with debugging via LLDB that can be found <a href="https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html">here</a>.</p>




<p>We will look at some of the most important commands after hooking into an application. In this case, lets start debugging the Twitter app. So make sure that the Twitter app is running in the foreground on the device and start a listener for the Twitter app.</p>


<p><img src="http://prateek147.github.io/images/posts/ios42/1.png" width="604" height="156" alt="1"></p>

<!-- more -->




<p>On your system, do the usual process of connecting to the debugserver application on the device to perform remote debugging. You can also use usbmuxd if you feel that debugging over Wifi is slow.</p>


<p><img src="http://prateek147.github.io/images/posts/ios42/2.png" width="913" height="653" alt="2"></p>

<p>Once the connection has been established, you can now run debbugger commands to analyze the application. Let's print out the AppDelegate object.</p>


<p><img src="http://prateek147.github.io/images/posts/ios42/3.png" width="485" height="62" alt="3"></p>

<p>We can read registers using the <i>register read</i> command. To read all the registers, use the <i>register read --all</i> command.</p>


<p><img src="http://prateek147.github.io/images/posts/ios42/4.png" width="706" height="613" alt="4"></p>

<p>Note the difference in the registers ? It's because of the new arm64 architecture for this application. Another important command is <i>image list</i> which will let you identify the location of the main executable and all the shared libraries.</p>


<p><img src="http://prateek147.github.io/images/posts/ios42/5.png" width="963" height="534" alt="5"></p>

<p>The <i>image dump sections</i> command will dump all the sections of the main executable and the shared libraries. You can later use this to dump information from the memory.</p>


<p><img src="http://prateek147.github.io/images/posts/ios42/6.png" width="1107" height="534" alt="6"></p>

<p>Setting a breakpoint is very similar to GDB. First, see if there are any breakpoints set using the <i>br l</i>. Then set a breakpoint for the objc_msgSend function using the <i>b objc_msgSend</i> command. Then, resume the application using the <i>process continue</i> command.</p>


<p><img src="http://prateek147.github.io/images/posts/ios42/7.png" width="716" height="80" alt="7"></p>

<p><img src="http://prateek147.github.io/images/posts/ios42/8.png" width="441" height="222" alt="8"></p>

<p>Once a breakpoint is hit, you can use the command <i>di -f</i> to see the disassembled code.</p>


<p><img src="http://prateek147.github.io/images/posts/ios42/9.png" width="702" height="331" alt="9"></p>

<p>We can also configure LLDB to execute a command once every breakpoint is hit. This could be very handy in tracing method calls in the application. To do that, use the command <i>target stop-hook add</i> and enter the commands that you want to enter once the breakpoint is hit. In this case, i have asked LLDB to print out all the registers and continue the program execution. </p>


<p><img src="http://prateek147.github.io/images/posts/ios42/10.png" width="961" height="484" alt="10"></p>

<p>If you don't understand the purpose of these registers right now, don't worry. I will cover arm64 architecture in a later article.</p>




<p>It is usually a good idea to strip the debug symbols from the application binary before submitting to the App store. You can do this by going to Build Settings and set the option <i>Strip Debug Symbols During Copy</i> to Yes.</p>


<p><img src="http://prateek147.github.io/images/posts/ios42/11.png" width="937" height="509" alt="11"></p>

<p>Hope you enjoyed this article. We have just scratched the surface of LLDB right now. In the next article, we will look at importing symbols from binaries and settings breakpoints on application specific methods.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Application Security Part 41 - Debugging applications using LLDB]]></title>
    <link href="http://prateek147.github.io/2015/04/28/ios-application-security-part-41-debugging-applications-using-lldb"/>
    <updated>2015-04-28T01:26:00+04:00</updated>
    <id>http://prateek147.github.io/2015/04/28/ios-application-security-part-41-debugging-applications-using-lldb</id>
    <content type="html"><![CDATA[<p>In this article we will learn about the LLDB debugger used by Apple's Xcode for debugging applications, understand why it is better for security testing, and then learn how to use it to debug iOS applications.</p>




<p>The following excerpt is from Apple's documentation.</p>




<p>LLDB is Apple's <i>from the ground up</i> replacement for GDB, developed in close coordination with the LLVM compilers to bring you state-of-the-art debugging with extensive capabilities in flow control and data inspection. Starting with Xcode 5, all new and preexisting development projects are automatically reconfigured to use LLDB. The standard LLDB installation provides you with an extensive set of commands designed to be compatible with familiar GDB commands. In addition to using the standard configuration, you can easily customize LLDB to suit your needs</p>




<p>A good way to start leaning about the LLDB debugger is to watch this video from WWDC 2014.</p>




<iframe width="420" height="315" src="https://www.youtube.com/embed/IPhgcbuDk_k" frameborder="0" allowfullscreen></iframe>




<p>But the question that remains is, why is LLDB better than GDB ?</p>




<p>To sum it up, there are a few reasons for that.</p>




<ul>
    <li>It works well for iOS 8</li>
    <li>LLDB is much faster, has support for multithread programming, and is scriptable.</li>
    <li>LLDB understands the dot syntax. You can use something like <i>po self.propertyName</i> or even <i>po instanceVariable</i> to find any value of a property or instance variable while debugging applications.</li>
    <li>It has plug-in support for functionality and extensions.</li>
</ul>




<!-- more -->




<p>To debug applications on an iOS device, we will use the command line utility debugserver which is used by Apple's Xcode to debug applications on the device. Usually, it gets installed on the device automatically when a device is marked for development, which requires a valid provisioning profile, but it can only debug applications that were signed by that particular provisioning profile. This is because of lack of entitlement to allow task_for_pid(). Hence, in order to debug any application, we must create a new entitlement file with the mentioned flag set to true, sign the debug server application with that entitlement file, and then deploy the console app to the device. Please note that the current location of debugserver application on the Mac is a read-only ramdisk, hence the application must be copied to a different location before signing with the new entitlement file.</p>




<p>Hence, the first step to do is to mount Xcode's developer disk image on your Mac and copy the debugserver binary to a seperate location where you can resign it. Use the following command.</p>




<p><i>hdiutil attach /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/[ios version]\ \(12B411\)/DeveloperDiskImage.dmg</i></p>


<p><img src="http://prateek147.github.io/images/posts/ios41/1.png" width="648" height="343" alt="1"></p>

<p><img src="http://prateek147.github.io/images/posts/ios41/2.png" width="767" height="225" alt="2"></p>

<p>Once this is done, create a new file with the name entitlements.plist and enter the following data in it.</p>




<pre>
&lt?xml version="1.0" encoding="UTF-8"?&gt
&lt!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/ PropertyList-1.0.dtd"&gt
<plist version="1.0">
<dict>
    &ltkey&gtcom.apple.springboard.debugapplications</key>
    &lttrue/&gt
    &ltkey&gtrun-unsigned-code</key>
    &lttrue/&gt
    &ltkey&gtget-task-allow</key>
    &lttrue/&gt
    &ltkey&gttask_for_pid-allow</key>
    &lttrue/&gt
</dict> 
</plist>
</pre>




<p>Now, you have to resign the debugserver binary with the new entitlements file.</p>


<p><i>codesign -s &ndash; &mdash;entitlements entitlements.plist -f debugserver</i></p>

<p><img src="http://prateek147.github.io/images/posts/ios41/3.png" width="806" height="42" alt="3"></p>

<p>Once this is done, deploy the binary to the device. To start debugserver on the device, use the command shown below, and also specify the name of the application you want to hook to, which in this case is Twitter.</p>


<p><img src="http://prateek147.github.io/images/posts/ios41/4.png" width="624" height="163" alt="4"></p>

<p>Now on your computer, start lldb to enter the lldb interpreter. Now use the following commands as shown below to to connect to the device. Make sure to replace the IP address here with the IP address of your device.</p>


<p><img src="http://prateek147.github.io/images/posts/ios41/5.png" width="590" height="409" alt="5"></p>

<p>Once this is done, you will see that you are successfully able to debug the application.</p>


<p><img src="http://prateek147.github.io/images/posts/ios41/6.png" width="715" height="380" alt="6"></p>

<p>Now you can use the po command to print out specific objects instantiated in the application.</p>


<p><img src="http://prateek147.github.io/images/posts/ios41/7.png" width="451" height="84" alt="7"></p>

<p><img src="http://prateek147.github.io/images/posts/ios41/8.png" width="587" height="95" alt="8"></p>

<p>The syntax for LLDB is a bit different. For e.g, here is the syntax for printing all the register variables.</p>


<p><img src="http://prateek147.github.io/images/posts/ios41/9.png" width="705" height="500" alt="9"></p>

<p>That's it for this article. In this article, we learnt how to deploy LLDB to the device and use it to run some basic commands. In the next article, we will look at some advanced usage of LLDB and how it can be used to find  sensitive information in memory.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Application Security Part 40 - Testing apps on your Mac]]></title>
    <link href="http://prateek147.github.io/2015/04/28/ios-application-security-part-40-testing-apps-on-your-mac"/>
    <updated>2015-04-28T01:25:00+04:00</updated>
    <id>http://prateek147.github.io/2015/04/28/ios-application-security-part-40-testing-apps-on-your-mac</id>
    <content type="html"><![CDATA[<p>In this article, we will discuss the extent to which you can test applications on your Mac rather than the. This could be useful for many reasons, sometimes you may not have a jailbroken but want to get a POC for a vulnerability. We will discuss what are the things you can and cannot do. To test the application on your system, you will need to have Xcode installed on your system and you will run the applications on the iOS simulator.</p>




<h3>Installing ipa files from iTunes on your simulator</h3>




<p>Sadly, there is no way you can do that. This is because the iTunes applications are compiled for the ARM platform whereas the applications that run on your simulator are compiled for the x86/x64 platform. So, to test any application properly on your Mac, you must have the source code of the application to run it on the simulator.</p>




<p>In this case, we are going to perform our testing on <a href="http://damnvulnerableiosapp.com">Damn Vulnerable iOS app</a></p>




<!-- more -->




<h3>Analyzing local data storage</h3>




<p>One of the most important things to check during performing penetration testing of iOS applications is checking for insecure local data storage vulnerabilites. You can easily check this by looking at the application folder created on your Mac by Xcode.This folder is available at the following locations.</p>




<p>iOS 8 - /Users/[username]/Library/Developer/CoreSimulator/Devices/[a unique number]/data/Containers/Data/Application/[another unique number]/ </p>


<p>iOS 7 - /Users/[username]/Library/Application Support/iPhone Simulator/[ios version]/Applications/[a unique id]/</p>




<p>Make sure to check this folder and see if the application is not storing any sensitive data to this folder.</p>




<h3>Checking logs</h3>




<p>You can easily check the logs that the applications is logging by looking at the logs section in Xcode. For example, over here, we can see that the application is logging sensitive data to the. However, if you see this behaviour, don't immediately report it as a vulnerability. Some developers add a check to detect whether the application is running on a simulator or a, and only log information if it is running on a simulator. If there is no such check, then this is definitely a vulnerability.</p>


<p><img src="http://prateek147.github.io/images/posts/ios40/2.png" width="882" height="602" alt="2"></p>

<h3>Attaching debuggers and Tracing method calls</h3>




<p>You can attach a debugger to the running application in the simulator. Its better to use LLDB debugger since it comes installed with Xcode command line tools. The iOS application running on the simulator can also be seen as a running process on your computer by using the command <i>ps aux</i>. You can attach to the running application both by using the pid or the name.</p>


<p><img src="http://prateek147.github.io/images/posts/ios40/lldb.png" width="511" height="249" alt="Lldb"></p>

<p>You can easily trace the method calls by using the inbuilt debugger LLDB in Xcode. To do that, you need to add a symbolic breakpoint in Xcode. See the plus arrow in the bottom left and click on it to add a symbolic breakpoint.</p>


<p><img src="http://prateek147.github.io/images/posts/ios40/3.png" width="759" height="441" alt="3"></p>

<p>Now set a breakpoint for the <i>objc_msgSend</i> call. Click on Add action and add the debugger command as <i>p (void)printf("[%s, %s]\n", (char*)object_getClassName($arg1), $arg2)</i> and make sure you check the option to continue execution of the program. You will notice that you are now able to trace all the method calls.</p>


<p><img src="http://prateek147.github.io/images/posts/ios40/4.png" width="885" height="802" alt="4"></p>

<h3>Attaching cycript</h3>




<p>You can even attach Cycript to the running application process in the simulator and demonstrate POC for vulnerabilities. Cycript works for Mac as well and you use the exact syntax that you use while auditing application on your.</p>


<p><img src="http://prateek147.github.io/images/posts/ios40/cycript.png" width="536" height="104" alt="Cycript"></p>

<h3>Monitoring Network traffic</h3>




<p>You can pretty much see all the network traffic over HTTP/HTTPs without any issues. You can either use Burpsuite or Charles for it. For HTTPs traffic, you will have to install the SSL certificate on your simulator. To do this, simply drag and drop the certificate file to your simulator, and click on install to install the certificate.</p>


<p><img src="http://prateek147.github.io/images/posts/ios40/cert.png" width="375" height="484" alt="Cert"></p>

<p>That's it for this article. In the next article, we will look at using the LLDB debugger for debugging iOS applications.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Damn Vulnerable iOS App solutions free for download]]></title>
    <link href="http://prateek147.github.io/2015/04/03/damn-vulnerable-ios-app-solutions-free-for-download"/>
    <updated>2015-04-03T16:26:00+04:00</updated>
    <id>http://prateek147.github.io/2015/04/03/damn-vulnerable-ios-app-solutions-free-for-download</id>
    <content type="html"><![CDATA[<p>I have decided to give away the solutions for DVIA for free. The reason for this has been too many people coming up with queries for the solutions and i believed giving away the solutions for free would really benefit the infosec community.
It has taken me a lot of nights and hard work to create this project and specially the solutions.
If you think this project has been useful to you and your organization, please consider making a donation to this project.
You can donate to this project and download the solutions for free from <a href="http://damnvulnerableiosapp.com/#solutions">here</a>.</p>

<p>-Prateek</p>
]]></content>
  </entry>
  
</feed>
